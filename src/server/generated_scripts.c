/* Generated file - DO NOT EDIT */
#include "generated_scripts.h"
#include <stddef.h>

static const char* QUERYBUILDER_CHUNKS[] = {
    "local QueryBuilder = {}\nQueryBuilder.__index = QueryBuilder\n\nfunction QueryBuilder.new()\n    local self = {\n        _selects = {},\n        _from = nil,\n        _wheres = {},\n        _orderBy = nil,\n        _limit = nil,\n        _offset = nil,\n        _params = {},\n        _withMeta = false,\n        _metaFields = {}\n    }\n    return setmetatable(self, QueryBuilder)\nend\n\nfunction QueryBuilder:select(...)\n    self._selects = {...}\n    return self\nend\n\nfunction QueryBuilder:from(table)\n    self._from = table\n    return self\nend\n\nfunction QueryBuilder:where(condition, ...)\n    local params = {...}\n    -- Replace ? with $N based on total param count\n    local param_count = #self._params\n    local modified_condition = condition:gsub(\"?\", function()\n        param_count = param_count + 1\n        return \"$\" .. param_count\n    end)\n    table.insert(self._wheres, {cond = modified_condition, params = params})\n    for _, param in ipairs(params) do\n        if param ~= nil then\n            table.insert(self._params, param)\n        end\n    end\n    return self\nend\n\nfunction QueryBuilder:where_if(value, condition, ...)\n    if value ~= nil and value ~= \"\" then\n        return self:where(condition, ...)\n    end\n    return self\nend\n\nfunction QueryBuilder:order_by(expr)\n    self._orderBy = expr\n    return self\nend\n\nfunction QueryBuilder:limit(n)\n    if n then\n        self._limit = tonumber(n)\n    end\n    return self\nend\n\nfunction QueryBuilder:offset(n)\n    if n then\n        self._offset = tonumber(n)\n    end\n    return self\nend\n\nfunction QueryBuilder:with_metadata(fields)\n    self._withMeta = true\n    self._metaFields = fields or {}\n    return self\nend\n\nfunction QueryBuilder:_build_select()\n    if self._withMeta then\n        -- Build NULL fields for metadata based on selected fields\n        local null_fields = {}\n        for _, field in ipairs(self._selects) do\n            local field_name = field:match(\"([^%s]+)%s+[aA][sS]%s+\") or field\n            field_name = field_name:match(\"%.([^%.]+",
    ")$\") or field_name\n            \n            local field_type = self._metaFields[field_name]\n            if not field_type then\n                if field_name == \"id\" then\n                    field_type = \"bigint\"\n                elseif field_name:match(\"_id$\") then\n                    field_type = \"integer\"\n                elseif field_name:match(\"count$\") then\n                    field_type = \"bigint\"\n                else\n                    field_type = \"text\"\n                end\n            end\n            \n            table.insert(null_fields, string.format(\"NULL::%s as %s\", field_type, field_name))\n        end\n        local null_fields_str = table.concat(null_fields, \", \")\n\n        -- Build core query without LIMIT/OFFSET\n        local core_parts = {}\n        local select_clause = \"SELECT \" .. (#self._selects > 0 and table.concat(self._selects, \", \") or \"*\")\n        table.insert(core_parts, select_clause)\n        if self._from then table.insert(core_parts, \"FROM \" .. self._from) end\n        if #self._wheres > 0 then\n            local conditions = {}\n            for _, where in ipairs(self._wheres) do\n                table.insert(conditions, where.cond)\n            end\n            table.insert(core_parts, \"WHERE \" .. table.concat(conditions, \" AND \"))\n        end\n        if self._orderBy then table.insert(core_parts, \"ORDER BY \" .. self._orderBy) end\n        local core_query = table.concat(core_parts, \" \")\n\n        -- Build the complete query with pagination and metadata\n        return string.format([[\n            WITH base_query AS (\n                %s\n            ),\n            total_count AS (\n                SELECT COUNT(*) as count FROM base_query\n            ),\n            paginated_data AS (\n                SELECT base_query.*, total_count.count as total_count\n                FROM base_query, total_count\n                %s\n                %s\n            )\n            (\n                SELECT \n                    'data'::text as type,\n                    NU",
    "LL::bigint as total_count,\n                    %s,\n                    NULL::integer as offset,\n                    NULL::integer as limit,\n                    NULL::boolean as has_more\n                FROM paginated_data\n            )\n            UNION ALL\n            (\n                SELECT\n                    'metadata'::text as type,\n                    count::bigint as total_count,\n                    %s,\n                    %s as offset,\n                    %s as limit,\n                    EXISTS (\n                        SELECT 1 FROM base_query\n                        OFFSET %s + %s\n                        LIMIT 1\n                    ) as has_more\n                FROM total_count\n            )\n            ORDER BY type DESC\n        ]], \n        core_query,\n        self._limit and string.format(\"LIMIT %d\", self._limit) or \"\",\n        self._offset and string.format(\"OFFSET %d\", self._offset) or \"\",\n        table.concat(self._selects, \", \"),\n        null_fields_str,\n        self._offset or \"0\",\n        self._limit or \"20\",\n        self._offset or \"0\",\n        self._limit or \"20\")\n    else\n        return self:_build_core()\n    end\nend\n\nfunction QueryBuilder:_build_core()\n    local parts = {}\n    local select_clause = \"SELECT \" .. (#self._selects > 0 and table.concat(self._selects, \", \") or \"*\")\n    table.insert(parts, select_clause)\n    if self._from then table.insert(parts, \"FROM \" .. self._from) end\n    if #self._wheres > 0 then\n        local conditions = {}\n        for _, where in ipairs(self._wheres) do\n            table.insert(conditions, where.cond)\n        end\n        table.insert(parts, \"WHERE \" .. table.concat(conditions, \" AND \"))\n    end\n    if self._orderBy then table.insert(parts, \"ORDER BY \" .. self._orderBy) end\n    if self._limit then table.insert(parts, \"LIMIT \" .. tostring(self._limit)) end\n    if self._offset then table.insert(parts, \"OFFSET \" .. tostring(self._offset)) end\n    return table.concat(parts, \" \")\nend\n\nfunction QueryBuilder:build(",
    ")\n    return {\n        sql = self:_build_select(),\n        sqlParams = self._params\n    }\nend\n\nreturn {\n    new = QueryBuilder.new\n}\n",
};

const EmbeddedScript EMBEDDED_SCRIPTS[] = {
    {
        .name = "querybuilder",
        .chunks = QUERYBUILDER_CHUNKS,
        .num_chunks = 4
    },
    { NULL, NULL, 0 }  /* Terminator */
};
